---
import Layout from "@/layouts/Layout.astro";
import SaltogramApp from "@/components/saltogram/SaltogramApp";
import { getSession } from "auth-astro/server";
import { getSaltogramStats, getTrendingTags } from "@/lib/saltogram";
import { client } from "@/db/client";
import { FriendsTable, UsersTable, SaltogramPostsTable } from "@/db/schema";
import { eq, and, notInArray, sql } from "drizzle-orm";
import type { SaltogramPost } from "@/types/saltogram";

const requestPath = Astro.url.pathname;
if (!requestPath.startsWith("/saltogram")) {
  return Astro.response(new Response(null, { status: 404 }));
}

const session = await getSession(Astro.request);
const stats = await getSaltogramStats();
const trendingTags = await getTrendingTags();

const friendRequests = session?.user?.id
  ? await client
      .select({
        id: FriendsTable.id,
        createdAt: FriendsTable.createdAt,
        user: {
          id: UsersTable.id,
          displayName: UsersTable.displayName,
          username: UsersTable.username,
          avatar: UsersTable.avatar,
        },
      })
      .from(FriendsTable)
      .innerJoin(UsersTable, eq(FriendsTable.userId, UsersTable.id))
      .where(
        and(
          eq(FriendsTable.friendId, Number(session.user.id)),
          eq(FriendsTable.status, "pending")
        )
      )
      .limit(4)
  : [];

let suggestedUsers: any[] = [];
if (session?.user?.id) {
  const currentUserId = Number(session.user.id);

  const friends1 = await client
    .select({ id: FriendsTable.friendId })
    .from(FriendsTable)
    .where(eq(FriendsTable.userId, currentUserId));
  const friends2 = await client
    .select({ id: FriendsTable.userId })
    .from(FriendsTable)
    .where(eq(FriendsTable.friendId, currentUserId));

  const excludeIds = [
    currentUserId,
    ...friends1.map((f) => f.id),
    ...friends2.map((f) => f.id),
  ];

  suggestedUsers = await client
    .select({
      id: UsersTable.id,
      displayName: UsersTable.displayName,
      username: UsersTable.username,
      avatar: UsersTable.avatar,
    })
    .from(UsersTable)
    .where(notInArray(UsersTable.id, excludeIds))
    .limit(4)
    .orderBy(sql`RANDOM()`);
}

const saltogramSegments = requestPath.split("/").filter(Boolean).slice(1); // remove leading "saltogram"

let initialPost: SaltogramPost | null = null;

if (saltogramSegments[0] === "post" && saltogramSegments[1]) {
  const postId = Number(saltogramSegments[1]);
  if (!Number.isNaN(postId)) {
    const posts = await client
      .select({
        id: SaltogramPostsTable.id,
        userId: SaltogramPostsTable.userId,
        text: SaltogramPostsTable.text,
        imageUrl: SaltogramPostsTable.imageUrl,
        isPinned: SaltogramPostsTable.isPinned,
        isFeatured: SaltogramPostsTable.isFeatured,
        featuredUntil: SaltogramPostsTable.featuredUntil,
        metadata: SaltogramPostsTable.metadata,
        createdAt: SaltogramPostsTable.createdAt,
        user: {
          id: UsersTable.id,
          displayName: UsersTable.displayName,
          username: UsersTable.username,
          avatar: UsersTable.avatar,
          admin: UsersTable.admin,
          twitchTier: UsersTable.twitchTier,
        },
        reactionsCount: sql<number>`
          (SELECT COUNT(*)::int FROM saltogram_reactions WHERE post_id = ${SaltogramPostsTable.id})
        `,
        commentsCount: sql<number>`
          (SELECT COUNT(*)::int FROM saltogram_comments WHERE post_id = ${SaltogramPostsTable.id})
        `,
        latestComments: sql<any[]>`
          (
            SELECT COALESCE(json_agg(c), '[]'::json)
            FROM (
                SELECT 
                    sc.id, 
                    sc.text, 
                    sc.created_at as "createdAt",
                    sc.parent_id as "parentId",
                    json_build_object(
                        'id', u.id,
                        'displayName', u.display_name,
                        'username', u.username,
                        'avatar', u.avatar,
                        'admin', u.admin,
                        'twitchTier', u.twitch_tier
                    ) as user
                FROM saltogram_comments sc
                JOIN users u ON sc.user_id = u.id
                WHERE sc.post_id = ${SaltogramPostsTable.id} AND sc.parent_id IS NULL
                ORDER BY sc.created_at DESC
                LIMIT 2
            ) c
          )
        `,
      })
      .from(SaltogramPostsTable)
      .innerJoin(UsersTable, eq(SaltogramPostsTable.userId, UsersTable.id))
      .where(eq(SaltogramPostsTable.id, postId))
      .limit(1);

    initialPost = posts[0]
      ? ({
          ...posts[0],
          createdAt: posts[0].createdAt.toISOString(),
          featuredUntil: posts[0].featuredUntil?.toISOString() ?? null,
        } as unknown as SaltogramPost)
      : null;
  }
}

const pageTitle = initialPost
  ? `${initialPost.user.displayName} en Saltogram`
  : "Saltogram";
---

<Layout
  title={pageTitle}
  hideFooter={true}
  hideHeader={true}
  mainClassname="px-4 sm:px-8 pt-4 pb-16"
>
  <SaltogramApp
    client:only="preact"
    user={session?.user}
    stats={stats}
    trendingTags={trendingTags}
    friendRequests={friendRequests.map((request) => ({
      ...request,
      createdAt: request.createdAt?.toISOString?.() ?? request.createdAt,
    }))}
    suggestedUsers={suggestedUsers}
    initialRoute={requestPath}
    basePath="/saltogram"
    initialPost={initialPost ?? undefined}
  />
</Layout>
